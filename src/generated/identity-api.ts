/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Identity Service API
 * API for Alfred Identity Management System
 * OpenAPI spec version: v1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from '../libs/custom-instance';
import type { ErrorType } from '../libs/custom-instance';

export interface ActivityLogDto {
  userId?: string;
  action?: string;

  /** @nullable */
  description?: string | null;

  /** @nullable */
  ipAddress?: string | null;

  /** @nullable */
  userAgent?: string | null;
  occurredAt?: string;
}

export interface ActivityLogDtoPageResult {
  items?: ActivityLogDto[];
  page?: number;
  pageSize?: number;
  total?: number;
  readonly totalPages?: number;
  readonly hasPrevPage?: boolean;
  readonly hasNextPage?: boolean;

  /** @nullable */
  readonly prevPage?: number | null;

  /** @nullable */
  readonly nextPage?: number | null;
}

/**
 * Error detail with message and i18n code
 */
export interface ApiError {
  message: string;
  code: string;
}

/**
 * Paginated API response (unified with error support).
Same discriminated union pattern as ApiResponse.
 */
export interface ActivityLogDtoApiPagedResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: ActivityLogDtoPageResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface AddPermissionsToRoleResult {
  success?: boolean;

  /** @nullable */
  error?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface AddPermissionsToRoleResultApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: AddPermissionsToRoleResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Non-generic API error response for use when no result type is needed.
Convenience type for error-only responses (e.g. global exception handler).
 */
export interface ApiErrorResponse {
  success: boolean;
  errors: ApiError[];
}

export interface ApplicationDto {
  id?: string;
  clientId?: string;

  /** @nullable */
  clientSecret?: string | null;

  /** @nullable */
  displayName?: string | null;

  /** @nullable */
  redirectUris?: string[] | null;

  /** @nullable */
  postLogoutRedirectUris?: string[] | null;

  /** @nullable */
  permissions?: string[] | null;

  /** @nullable */
  applicationType?: string | null;

  /** @nullable */
  clientType?: string | null;
  isActive?: boolean;
  createdAt?: string;

  /** @nullable */
  updatedAt?: string | null;
}

export interface ApplicationDtoPageResult {
  items?: ApplicationDto[];
  page?: number;
  pageSize?: number;
  total?: number;
  readonly totalPages?: number;
  readonly hasPrevPage?: boolean;
  readonly hasNextPage?: boolean;

  /** @nullable */
  readonly prevPage?: number | null;

  /** @nullable */
  readonly nextPage?: number | null;
}

/**
 * Paginated API response (unified with error support).
Same discriminated union pattern as ApiResponse.
 */
export interface ApplicationDtoApiPagedResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: ApplicationDtoPageResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface ApplicationDtoApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: ApplicationDto | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface ApplicationMetadataDto {
  applicationTypes?: string[];
  clientTypes?: string[];
  grantTypes?: string[];
  scopes?: string[];
  endpoints?: string[];
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface ApplicationMetadataDtoApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: ApplicationMetadataDto | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface AssignRolesToUserResult {
  success?: boolean;

  /** @nullable */
  error?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface AssignRolesToUserResultApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: AssignRolesToUserResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface BanDto {
  userId?: string;
  reason?: string;
  bannedAt?: string;

  /** @nullable */
  bannedById?: string | null;

  /** @nullable */
  expiresAt?: string | null;
  isActive?: boolean;

  /** @nullable */
  unbannedAt?: string | null;

  /** @nullable */
  unbannedById?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface BanDtoListApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;

  /** @nullable */
  result?: BanDto[] | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Request model for banning a user
 */
export interface BanUserRequest {
  reason?: string;

  /** @nullable */
  expiresAt?: string | null;
}

export interface BanUserResult {
  isSuccess?: boolean;

  /** @nullable */
  error?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface BanUserResultApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: BanUserResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface BooleanApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: boolean;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface ChangePasswordRequest {
  oldPassword?: string;
  newPassword?: string;
}

export interface ConfirmTwoFactorRequest {
  code?: string;
}

/**
 * Request model for creating a new OAuth2 client application
 */
export interface CreateApplicationRequest {
  /**
   * Unique client identifier
   * @minLength 0
   * @maxLength 100
   */
  clientId: string;

  /**
   * Display name for the application
   * @minLength 0
   * @maxLength 200
   */
  displayName: string;

  /**
   * Comma-separated list of allowed redirect URIs
   * @minLength 1
   */
  redirectUris: string;

  /**
   * Comma-separated list of allowed post-logout redirect URIs
   * @nullable
   */
  postLogoutRedirectUris?: string | null;

  /**
   * Comma-separated list of permissions/scopes
   * @nullable
   */
  permissions?: string | null;

  /**
   * Application type: public or confidential
   * @pattern ^(public|confidential)$
   */
  type?: string;
}

export interface CreateRoleCommand {
  name?: string;

  /** @nullable */
  icon?: string | null;
  isImmutable?: boolean;
  isSystem?: boolean;

  /** @nullable */
  permissions?: string[] | null;
}

export interface ForgotPasswordRequest {
  email?: string;
}

export interface ProblemDetails {
  /** @nullable */
  type?: string | null;

  /** @nullable */
  title?: string | null;

  /** @nullable */
  status?: number | null;

  /** @nullable */
  detail?: string | null;

  /** @nullable */
  instance?: string | null;
  [key: string]: unknown;
}

export type HttpValidationProblemDetails = ProblemDetails & {
  errors?: { [key: string]: string[] };
  [key: string]: unknown;
};

export interface InitiateEnableTwoFactorResult {
  secret?: string;
  qrCodeUri?: string;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface InitiateEnableTwoFactorResultApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: InitiateEnableTwoFactorResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface ObjectApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: unknown | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface PermissionDto {
  id?: string;
  code?: string;
  name?: string;

  /** @nullable */
  description?: string | null;

  /** @nullable */
  resource?: string | null;

  /** @nullable */
  action?: string | null;

  /** @nullable */
  isActive?: boolean | null;
}

export interface PermissionDtoPageResult {
  items?: PermissionDto[];
  page?: number;
  pageSize?: number;
  total?: number;
  readonly totalPages?: number;
  readonly hasPrevPage?: boolean;
  readonly hasNextPage?: boolean;

  /** @nullable */
  readonly prevPage?: number | null;

  /** @nullable */
  readonly nextPage?: number | null;
}

/**
 * Paginated API response (unified with error support).
Same discriminated union pattern as ApiResponse.
 */
export interface PermissionDtoApiPagedResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: PermissionDtoPageResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface RemovePermissionsFromRoleResult {
  success?: boolean;

  /** @nullable */
  error?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface RemovePermissionsFromRoleResultApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: RemovePermissionsFromRoleResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface ResetPasswordRequest {
  email?: string;
  token?: string;
  newPassword?: string;
}

export interface RevokeRolesFromUserResult {
  success?: boolean;

  /** @nullable */
  error?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface RevokeRolesFromUserResultApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: RevokeRolesFromUserResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface RoleDto {
  id?: string;

  /** @nullable */
  name?: string | null;

  /** @nullable */
  normalizedName?: string | null;

  /** @nullable */
  isImmutable?: boolean | null;

  /** @nullable */
  isSystem?: boolean | null;

  /** @nullable */
  icon?: string | null;

  /** @nullable */
  isDeleted?: boolean | null;

  /** @nullable */
  createdAt?: string | null;

  /** @nullable */
  updatedAt?: string | null;

  /** @nullable */
  permissions?: PermissionDto[] | null;
}

export interface RoleDtoPageResult {
  items?: RoleDto[];
  page?: number;
  pageSize?: number;
  total?: number;
  readonly totalPages?: number;
  readonly hasPrevPage?: boolean;
  readonly hasNextPage?: boolean;

  /** @nullable */
  readonly prevPage?: number | null;

  /** @nullable */
  readonly nextPage?: number | null;
}

/**
 * Paginated API response (unified with error support).
Same discriminated union pattern as ApiResponse.
 */
export interface RoleDtoApiPagedResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: RoleDtoPageResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface RoleDtoApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: RoleDto | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface RotateSigningKeyResult {
  success?: boolean;
  newKeyId?: string;

  /** @nullable */
  error?: string | null;
}

/**
 * User info for session response
 */
export interface SessionUserInfoDto {
  /** User ID (Guid - matches DB schema) */
  id?: string;
  email?: string;

  /** @nullable */
  fullName?: string | null;

  /** @nullable */
  userName?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface SessionUserInfoDtoApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;

  /** User info for session response */
  result?: SessionUserInfoDto | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Request model for SSO login (sets authentication cookie)
 */
export interface SsoLoginRequest {
  /**
   * User identity - can be email or username
   * @minLength 0
   * @maxLength 256
   */
  identity: string;

  /**
   * User password
   * @minLength 6
   */
  password: string;

  /**
   * URL to redirect after successful login (OIDC flow)
   * @nullable
   */
  returnUrl?: string | null;

  /** Remember me - extends cookie validity */
  rememberMe?: boolean;
}

export interface UserInfo {
  id?: string;
  email?: string;

  /** @nullable */
  userName?: string | null;

  /** @nullable */
  fullName?: string | null;
}

/**
 * Response for SSO Login
 */
export interface SsoLoginResponse {
  /** Exchange URL for browser navigation to set cookie (Token Exchange Pattern) */
  returnUrl: string;

  /** User information for UI display */
  user?: UserInfo;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface SsoLoginResponseApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;

  /** Response for SSO Login */
  result?: SsoLoginResponse | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Response for SSO Session check
 */
export interface SsoSessionResponse {
  /** Whether user is authenticated */
  isAuthenticated?: boolean;

  /** User info if authenticated */
  user?: SessionUserInfoDto | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface SsoSessionResponseApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;

  /** Response for SSO Session check */
  result?: SsoSessionResponse | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface StringApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;

  /** @nullable */
  result?: string | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface StringIEnumerableApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;

  /** @nullable */
  result?: string[] | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export interface UnbanUserResult {
  isSuccess?: boolean;

  /** @nullable */
  error?: string | null;
}

/**
 * Unified API response wrapper for all API responses (success + error).
- On success: Success=true, Result is populated, Errors is null.
- On failure: Success=false, Errors is populated, Result is null.
            
This enables discriminated union pattern on the frontend:
  if (data.success) { data.result... } else { data.errors... }
 */
export interface UnbanUserResultApiResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: UnbanUserResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

/**
 * Request model for updating an OAuth2 client application
 */
export interface UpdateApplicationRequest {
  /**
   * Display name for the application
   * @minLength 0
   * @maxLength 200
   */
  displayName: string;

  /**
   * Comma-separated list of allowed redirect URIs
   * @minLength 1
   */
  redirectUris: string;

  /**
   * Comma-separated list of allowed post-logout redirect URIs
   * @nullable
   */
  postLogoutRedirectUris?: string | null;

  /**
   * Comma-separated list of permissions/scopes
   * @nullable
   */
  permissions?: string | null;
}

export interface UpdateApplicationStatusRequest {
  isActive?: boolean;
}

export interface UpdateRoleCommand {
  id?: string;
  name?: string;

  /** @nullable */
  icon?: string | null;
  isImmutable?: boolean;
  isSystem?: boolean;

  /** @nullable */
  permissions?: string[] | null;
}

export interface UserDto {
  id?: string;

  /** @nullable */
  userName?: string | null;

  /** @nullable */
  email?: string | null;

  /** @nullable */
  fullName?: string | null;

  /** @nullable */
  status?: string | null;

  /** @nullable */
  emailConfirmed?: boolean | null;

  /** @nullable */
  phoneNumber?: string | null;

  /** @nullable */
  avatar?: string | null;

  /** @nullable */
  createdAt?: string | null;
  roles?: RoleDto[];
}

export interface UserDtoPageResult {
  items?: UserDto[];
  page?: number;
  pageSize?: number;
  total?: number;
  readonly totalPages?: number;
  readonly hasPrevPage?: boolean;
  readonly hasNextPage?: boolean;

  /** @nullable */
  readonly prevPage?: number | null;

  /** @nullable */
  readonly nextPage?: number | null;
}

/**
 * Paginated API response (unified with error support).
Same discriminated union pattern as ApiResponse.
 */
export interface UserDtoApiPagedResponse {
  success: boolean;

  /** @nullable */
  message?: string | null;
  result?: UserDtoPageResult | null;

  /** @nullable */
  errors?: ApiError[] | null;
}

export type GetApplicationsParams = {
  /**
   * Page number (1-based)
   */
  page?: number;

  /**
   * Number of items per page
   */
  pageSize?: number;

  /**
 * Filter expression using DSL syntax
Examples: "name @contains('abc')", "phone == '123' or phone == '321'"
 */
  filter?: string;

  /**
 * Sort expression (comma-separated)
Example: "name,-createdAt" (ascending by name, descending by createdAt)
 */
  sort?: string;

  /**
 * View name to determine which fields to return.
Available views depend on the endpoint (e.g., "list", "detail", "minimal").
 */
  view?: string;
};

export type GetIdentityAuthExchangeTokenParams = {
  token?: string;
  returnUrl?: string;
};

export type GetIdentityAuthCheckSsoParams = {
  returnUrl?: string;
};

export type GetIdentityAuthValidateTokenParams = {
  token?: string;
};

export type GetConnectAuthorizeParams = {
  /**
   * Client Identifier
   */
  client_id?: string;

  /**
   * URI to return the code/token to
   */
  redirect_uri?: string;

  /**
   * Response Type (e.g., 'code')
   */
  response_type?: string;

  /**
   * Requested scopes (space-separated)
   */
  scope?: string;

  /**
   * Client state for CSRF protection
   */
  state?: string;

  /**
   * PKCE Code Challenge
   */
  code_challenge?: string;

  /**
   * PKCE Method (S256)
   */
  code_challenge_method?: string;

  /**
   * Prompt behavior (e.g., 'none', 'login')
   */
  prompt?: string;
};

export type PostConnectAuthorizeParams = {
  /**
   * Client Identifier
   */
  client_id?: string;

  /**
   * URI to return the code/token to
   */
  redirect_uri?: string;

  /**
   * Response Type (e.g., 'code')
   */
  response_type?: string;

  /**
   * Requested scopes (space-separated)
   */
  scope?: string;

  /**
   * Client state for CSRF protection
   */
  state?: string;

  /**
   * PKCE Code Challenge
   */
  code_challenge?: string;

  /**
   * PKCE Method (S256)
   */
  code_challenge_method?: string;

  /**
   * Prompt behavior (e.g., 'none', 'login')
   */
  prompt?: string;
};

export type PostConnectTokenBody = {
  /** Grant Type ('authorization_code' or 'refresh_token') */
  grant_type?: string;

  /** Client Identifier */
  client_id?: string;

  /** Client Secret (for confidential clients) */
  client_secret?: string;

  /** Authorization Code (for authorization_code grant) */
  code?: string;

  /** Redirect URI used in authorize request */
  redirect_uri?: string;

  /** PKCE Code Verifier */
  code_verifier?: string;

  /** Refresh Token (for refresh_token grant) */
  refresh_token?: string;

  /** Requested scopes (optional) */
  scope?: string;
};

export type GetConnectLogoutParams = {
  client_id?: string;
  post_logout_redirect_uri?: string;
  id_token_hint?: string;
  state?: string;
};

export type GetIdentityExternalAuthChallengeParams = {
  provider?: string;
  returnUrl?: string;
};

export type GetIdentityExternalAuthCallbackParams = {
  returnUrl?: string;
};

export type GetPermissionsParams = {
  /**
   * Page number (1-based)
   */
  page?: number;

  /**
   * Number of items per page
   */
  pageSize?: number;

  /**
 * Filter expression using DSL syntax
Examples: "name @contains('abc')", "phone == '123' or phone == '321'"
 */
  filter?: string;

  /**
 * Sort expression (comma-separated)
Example: "name,-createdAt" (ascending by name, descending by createdAt)
 */
  sort?: string;

  /**
 * View name to determine which fields to return.
Available views depend on the endpoint (e.g., "list", "detail", "minimal").
 */
  view?: string;
};

export type GetRolesParams = {
  /**
   * Page number (1-based)
   */
  page?: number;

  /**
   * Number of items per page
   */
  pageSize?: number;

  /**
 * Filter expression using DSL syntax
Examples: "name @contains('abc')", "phone == '123' or phone == '321'"
 */
  filter?: string;

  /**
 * Sort expression (comma-separated)
Example: "name,-createdAt" (ascending by name, descending by createdAt)
 */
  sort?: string;

  /**
 * View name to determine which fields to return.
Available views depend on the endpoint (e.g., "list", "detail", "minimal").
 */
  view?: string;
};

export type GetUsersParams = {
  /**
   * Page number (1-based)
   */
  page?: number;

  /**
   * Number of items per page
   */
  pageSize?: number;

  /**
 * Filter expression using DSL syntax
Examples: "name @contains('abc')", "phone == '123' or phone == '321'"
 */
  filter?: string;

  /**
 * Sort expression (comma-separated)
Example: "name,-createdAt" (ascending by name, descending by createdAt)
 */
  sort?: string;

  /**
 * View name to determine which fields to return.
Available views depend on the endpoint (e.g., "list", "detail", "minimal").
 */
  view?: string;
};

export type GetUsersUserIdActivitiesParams = {
  page?: number;
  pageSize?: number;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Change current user's password
 */
export const getPostIdentityAccountChangePasswordUrl = () => {
  return `/identity/account/change-password`;
};

export const postIdentityAccountChangePassword = async (
  changePasswordRequest: ChangePasswordRequest,
  options?: RequestInit
): Promise<ObjectApiResponse> => {
  return customInstance<ObjectApiResponse>(getPostIdentityAccountChangePasswordUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(changePasswordRequest)
  });
};

export const getPostIdentityAccountChangePasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postIdentityAccountChangePassword>>,
    TError,
    { data: ChangePasswordRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postIdentityAccountChangePassword>>,
  TError,
  { data: ChangePasswordRequest },
  TContext
> => {
  const mutationKey = ['postIdentityAccountChangePassword'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postIdentityAccountChangePassword>>,
    { data: ChangePasswordRequest }
  > = props => {
    const { data } = props ?? {};

    return postIdentityAccountChangePassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAccountChangePasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof postIdentityAccountChangePassword>>
>;
export type PostIdentityAccountChangePasswordMutationBody = ChangePasswordRequest;
export type PostIdentityAccountChangePasswordMutationError = ErrorType<unknown>;

/**
 * @summary Change current user's password
 */
export const usePostIdentityAccountChangePassword = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postIdentityAccountChangePassword>>,
      TError,
      { data: ChangePasswordRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postIdentityAccountChangePassword>>,
  TError,
  { data: ChangePasswordRequest },
  TContext
> => {
  return useMutation(getPostIdentityAccountChangePasswordMutationOptions(options), queryClient);
};

/**
 * @summary Initiate 2FA Setup (Enable)
 */
export const getPostIdentityAccount2faEnableUrl = () => {
  return `/identity/account/2fa/enable`;
};

export const postIdentityAccount2faEnable = async (
  options?: RequestInit
): Promise<InitiateEnableTwoFactorResultApiResponse> => {
  return customInstance<InitiateEnableTwoFactorResultApiResponse>(getPostIdentityAccount2faEnableUrl(), {
    ...options,
    method: 'POST'
  });
};

export const getPostIdentityAccount2faEnableMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIdentityAccount2faEnable>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof postIdentityAccount2faEnable>>, TError, void, TContext> => {
  const mutationKey = ['postIdentityAccount2faEnable'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIdentityAccount2faEnable>>, void> = () => {
    return postIdentityAccount2faEnable(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAccount2faEnableMutationResult = NonNullable<
  Awaited<ReturnType<typeof postIdentityAccount2faEnable>>
>;

export type PostIdentityAccount2faEnableMutationError = ErrorType<unknown>;

/**
 * @summary Initiate 2FA Setup (Enable)
 */
export const usePostIdentityAccount2faEnable = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIdentityAccount2faEnable>>, TError, void, TContext>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postIdentityAccount2faEnable>>, TError, void, TContext> => {
  return useMutation(getPostIdentityAccount2faEnableMutationOptions(options), queryClient);
};

/**
 * @summary Confirm 2FA Setup and get recovery codes
 */
export const getPostIdentityAccount2faConfirmUrl = () => {
  return `/identity/account/2fa/confirm`;
};

export const postIdentityAccount2faConfirm = async (
  confirmTwoFactorRequest: ConfirmTwoFactorRequest,
  options?: RequestInit
): Promise<StringIEnumerableApiResponse> => {
  return customInstance<StringIEnumerableApiResponse>(getPostIdentityAccount2faConfirmUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(confirmTwoFactorRequest)
  });
};

export const getPostIdentityAccount2faConfirmMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postIdentityAccount2faConfirm>>,
    TError,
    { data: ConfirmTwoFactorRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postIdentityAccount2faConfirm>>,
  TError,
  { data: ConfirmTwoFactorRequest },
  TContext
> => {
  const mutationKey = ['postIdentityAccount2faConfirm'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postIdentityAccount2faConfirm>>,
    { data: ConfirmTwoFactorRequest }
  > = props => {
    const { data } = props ?? {};

    return postIdentityAccount2faConfirm(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAccount2faConfirmMutationResult = NonNullable<
  Awaited<ReturnType<typeof postIdentityAccount2faConfirm>>
>;
export type PostIdentityAccount2faConfirmMutationBody = ConfirmTwoFactorRequest;
export type PostIdentityAccount2faConfirmMutationError = ErrorType<unknown>;

/**
 * @summary Confirm 2FA Setup and get recovery codes
 */
export const usePostIdentityAccount2faConfirm = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postIdentityAccount2faConfirm>>,
      TError,
      { data: ConfirmTwoFactorRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postIdentityAccount2faConfirm>>,
  TError,
  { data: ConfirmTwoFactorRequest },
  TContext
> => {
  return useMutation(getPostIdentityAccount2faConfirmMutationOptions(options), queryClient);
};

/**
 * @summary Disable 2FA
 */
export const getPostIdentityAccount2faDisableUrl = () => {
  return `/identity/account/2fa/disable`;
};

export const postIdentityAccount2faDisable = async (options?: RequestInit): Promise<ObjectApiResponse> => {
  return customInstance<ObjectApiResponse>(getPostIdentityAccount2faDisableUrl(), {
    ...options,
    method: 'POST'
  });
};

export const getPostIdentityAccount2faDisableMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIdentityAccount2faDisable>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof postIdentityAccount2faDisable>>, TError, void, TContext> => {
  const mutationKey = ['postIdentityAccount2faDisable'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIdentityAccount2faDisable>>, void> = () => {
    return postIdentityAccount2faDisable(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAccount2faDisableMutationResult = NonNullable<
  Awaited<ReturnType<typeof postIdentityAccount2faDisable>>
>;

export type PostIdentityAccount2faDisableMutationError = ErrorType<unknown>;

/**
 * @summary Disable 2FA
 */
export const usePostIdentityAccount2faDisable = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIdentityAccount2faDisable>>, TError, void, TContext>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postIdentityAccount2faDisable>>, TError, void, TContext> => {
  return useMutation(getPostIdentityAccount2faDisableMutationOptions(options), queryClient);
};

/**
 * @summary Get paginated list of applications
 */
export const getGetApplicationsUrl = (params?: GetApplicationsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/applications?${stringifiedParams}` : `/applications`;
};

export const getApplications = async (
  params?: GetApplicationsParams,
  options?: RequestInit
): Promise<ApplicationDtoApiPagedResponse> => {
  return customInstance<ApplicationDtoApiPagedResponse>(getGetApplicationsUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetApplicationsQueryKey = (params?: GetApplicationsParams) => {
  return [`/applications`, ...(params ? [params] : [])] as const;
};

export const getGetApplicationsQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplications>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetApplicationsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplications>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetApplicationsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getApplications>>> = ({ signal }) =>
    getApplications(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApplications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationsQueryResult = NonNullable<Awaited<ReturnType<typeof getApplications>>>;
export type GetApplicationsQueryError = ErrorType<ApiErrorResponse>;

export function useGetApplications<
  TData = Awaited<ReturnType<typeof getApplications>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params: undefined | GetApplicationsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplications>>,
          TError,
          Awaited<ReturnType<typeof getApplications>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetApplications<
  TData = Awaited<ReturnType<typeof getApplications>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetApplicationsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplications>>,
          TError,
          Awaited<ReturnType<typeof getApplications>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetApplications<
  TData = Awaited<ReturnType<typeof getApplications>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetApplicationsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplications>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get paginated list of applications
 */

export function useGetApplications<
  TData = Awaited<ReturnType<typeof getApplications>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetApplicationsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplications>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetApplicationsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Create a new OAuth2 client application
 */
export const getPostApplicationsUrl = () => {
  return `/applications`;
};

export const postApplications = async (
  createApplicationRequest: CreateApplicationRequest,
  options?: RequestInit
): Promise<ApplicationDtoApiResponse> => {
  return customInstance<ApplicationDtoApiResponse>(getPostApplicationsUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createApplicationRequest)
  });
};

export const getPostApplicationsMutationOptions = <TError = ErrorType<ApiErrorResponse>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApplications>>,
    TError,
    { data: CreateApplicationRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApplications>>,
  TError,
  { data: CreateApplicationRequest },
  TContext
> => {
  const mutationKey = ['postApplications'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApplications>>,
    { data: CreateApplicationRequest }
  > = props => {
    const { data } = props ?? {};

    return postApplications(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApplicationsMutationResult = NonNullable<Awaited<ReturnType<typeof postApplications>>>;
export type PostApplicationsMutationBody = CreateApplicationRequest;
export type PostApplicationsMutationError = ErrorType<ApiErrorResponse>;

/**
 * @summary Create a new OAuth2 client application
 */
export const usePostApplications = <TError = ErrorType<ApiErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApplications>>,
      TError,
      { data: CreateApplicationRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postApplications>>,
  TError,
  { data: CreateApplicationRequest },
  TContext
> => {
  return useMutation(getPostApplicationsMutationOptions(options), queryClient);
};

/**
 * @summary Get application metadata (types, permissions)
 */
export const getGetApplicationsMetadataUrl = () => {
  return `/applications/metadata`;
};

export const getApplicationsMetadata = async (options?: RequestInit): Promise<ApplicationMetadataDtoApiResponse> => {
  return customInstance<ApplicationMetadataDtoApiResponse>(getGetApplicationsMetadataUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetApplicationsMetadataQueryKey = () => {
  return [`/applications/metadata`] as const;
};

export const getGetApplicationsMetadataQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplicationsMetadata>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsMetadata>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetApplicationsMetadataQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getApplicationsMetadata>>> = ({ signal }) =>
    getApplicationsMetadata({ signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApplicationsMetadata>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationsMetadataQueryResult = NonNullable<Awaited<ReturnType<typeof getApplicationsMetadata>>>;
export type GetApplicationsMetadataQueryError = ErrorType<unknown>;

export function useGetApplicationsMetadata<
  TData = Awaited<ReturnType<typeof getApplicationsMetadata>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsMetadata>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationsMetadata>>,
          TError,
          Awaited<ReturnType<typeof getApplicationsMetadata>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetApplicationsMetadata<
  TData = Awaited<ReturnType<typeof getApplicationsMetadata>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsMetadata>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationsMetadata>>,
          TError,
          Awaited<ReturnType<typeof getApplicationsMetadata>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetApplicationsMetadata<
  TData = Awaited<ReturnType<typeof getApplicationsMetadata>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsMetadata>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get application metadata (types, permissions)
 */

export function useGetApplicationsMetadata<
  TData = Awaited<ReturnType<typeof getApplicationsMetadata>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsMetadata>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetApplicationsMetadataQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get application by ID
 */
export const getGetApplicationsIdUrl = (id: string) => {
  return `/applications/${id}`;
};

export const getApplicationsId = async (id: string, options?: RequestInit): Promise<ApplicationDtoApiResponse> => {
  return customInstance<ApplicationDtoApiResponse>(getGetApplicationsIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

export const getGetApplicationsIdQueryKey = (id: string) => {
  return [`/applications/${id}`] as const;
};

export const getGetApplicationsIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplicationsId>>,
  TError = ErrorType<ApiErrorResponse>
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsId>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetApplicationsIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getApplicationsId>>> = ({ signal }) =>
    getApplicationsId(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApplicationsId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApplicationsId>>>;
export type GetApplicationsIdQueryError = ErrorType<ApiErrorResponse>;

export function useGetApplicationsId<
  TData = Awaited<ReturnType<typeof getApplicationsId>>,
  TError = ErrorType<ApiErrorResponse>
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationsId>>,
          TError,
          Awaited<ReturnType<typeof getApplicationsId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetApplicationsId<
  TData = Awaited<ReturnType<typeof getApplicationsId>>,
  TError = ErrorType<ApiErrorResponse>
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationsId>>,
          TError,
          Awaited<ReturnType<typeof getApplicationsId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetApplicationsId<
  TData = Awaited<ReturnType<typeof getApplicationsId>>,
  TError = ErrorType<ApiErrorResponse>
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsId>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get application by ID
 */

export function useGetApplicationsId<
  TData = Awaited<ReturnType<typeof getApplicationsId>>,
  TError = ErrorType<ApiErrorResponse>
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplicationsId>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetApplicationsIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Update an existing application
 */
export const getPutApplicationsIdUrl = (id: string) => {
  return `/applications/${id}`;
};

export const putApplicationsId = async (
  id: string,
  updateApplicationRequest: UpdateApplicationRequest,
  options?: RequestInit
): Promise<ApplicationDtoApiResponse> => {
  return customInstance<ApplicationDtoApiResponse>(getPutApplicationsIdUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateApplicationRequest)
  });
};

export const getPutApplicationsIdMutationOptions = <
  TError = ErrorType<ApiErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putApplicationsId>>,
    TError,
    { id: string; data: UpdateApplicationRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putApplicationsId>>,
  TError,
  { id: string; data: UpdateApplicationRequest },
  TContext
> => {
  const mutationKey = ['putApplicationsId'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putApplicationsId>>,
    { id: string; data: UpdateApplicationRequest }
  > = props => {
    const { id, data } = props ?? {};

    return putApplicationsId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutApplicationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putApplicationsId>>>;
export type PutApplicationsIdMutationBody = UpdateApplicationRequest;
export type PutApplicationsIdMutationError = ErrorType<ApiErrorResponse>;

/**
 * @summary Update an existing application
 */
export const usePutApplicationsId = <TError = ErrorType<ApiErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putApplicationsId>>,
      TError,
      { id: string; data: UpdateApplicationRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof putApplicationsId>>,
  TError,
  { id: string; data: UpdateApplicationRequest },
  TContext
> => {
  return useMutation(getPutApplicationsIdMutationOptions(options), queryClient);
};

/**
 * @summary Delete an application
 */
export const getDeleteApplicationsIdUrl = (id: string) => {
  return `/applications/${id}`;
};

export const deleteApplicationsId = async (id: string, options?: RequestInit): Promise<BooleanApiResponse> => {
  return customInstance<BooleanApiResponse>(getDeleteApplicationsIdUrl(id), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteApplicationsIdMutationOptions = <
  TError = ErrorType<ApiErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteApplicationsId>>, TError, { id: string }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteApplicationsId>>, TError, { id: string }, TContext> => {
  const mutationKey = ['deleteApplicationsId'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApplicationsId>>, { id: string }> = props => {
    const { id } = props ?? {};

    return deleteApplicationsId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteApplicationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApplicationsId>>>;

export type DeleteApplicationsIdMutationError = ErrorType<ApiErrorResponse>;

/**
 * @summary Delete an application
 */
export const useDeleteApplicationsId = <TError = ErrorType<ApiErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteApplicationsId>>, TError, { id: string }, TContext>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteApplicationsId>>, TError, { id: string }, TContext> => {
  return useMutation(getDeleteApplicationsIdMutationOptions(options), queryClient);
};

/**
 * @summary Update application status (activate/deactivate)
 */
export const getPatchApplicationsIdStatusUrl = (id: string) => {
  return `/applications/${id}/status`;
};

export const patchApplicationsIdStatus = async (
  id: string,
  updateApplicationStatusRequest: UpdateApplicationStatusRequest,
  options?: RequestInit
): Promise<BooleanApiResponse> => {
  return customInstance<BooleanApiResponse>(getPatchApplicationsIdStatusUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateApplicationStatusRequest)
  });
};

export const getPatchApplicationsIdStatusMutationOptions = <
  TError = ErrorType<ApiErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchApplicationsIdStatus>>,
    TError,
    { id: string; data: UpdateApplicationStatusRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchApplicationsIdStatus>>,
  TError,
  { id: string; data: UpdateApplicationStatusRequest },
  TContext
> => {
  const mutationKey = ['patchApplicationsIdStatus'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchApplicationsIdStatus>>,
    { id: string; data: UpdateApplicationStatusRequest }
  > = props => {
    const { id, data } = props ?? {};

    return patchApplicationsIdStatus(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchApplicationsIdStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchApplicationsIdStatus>>
>;
export type PatchApplicationsIdStatusMutationBody = UpdateApplicationStatusRequest;
export type PatchApplicationsIdStatusMutationError = ErrorType<ApiErrorResponse>;

/**
 * @summary Update application status (activate/deactivate)
 */
export const usePatchApplicationsIdStatus = <TError = ErrorType<ApiErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchApplicationsIdStatus>>,
      TError,
      { id: string; data: UpdateApplicationStatusRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchApplicationsIdStatus>>,
  TError,
  { id: string; data: UpdateApplicationStatusRequest },
  TContext
> => {
  return useMutation(getPatchApplicationsIdStatusMutationOptions(options), queryClient);
};

/**
 * @summary Regenerate client secret (returns the new raw secret)
 */
export const getPostApplicationsIdSecretRegenerateUrl = (id: string) => {
  return `/applications/${id}/secret/regenerate`;
};

export const postApplicationsIdSecretRegenerate = async (
  id: string,
  options?: RequestInit
): Promise<StringApiResponse> => {
  return customInstance<StringApiResponse>(getPostApplicationsIdSecretRegenerateUrl(id), {
    ...options,
    method: 'POST'
  });
};

export const getPostApplicationsIdSecretRegenerateMutationOptions = <
  TError = ErrorType<ApiErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApplicationsIdSecretRegenerate>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApplicationsIdSecretRegenerate>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['postApplicationsIdSecretRegenerate'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApplicationsIdSecretRegenerate>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return postApplicationsIdSecretRegenerate(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApplicationsIdSecretRegenerateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApplicationsIdSecretRegenerate>>
>;

export type PostApplicationsIdSecretRegenerateMutationError = ErrorType<ApiErrorResponse>;

/**
 * @summary Regenerate client secret (returns the new raw secret)
 */
export const usePostApplicationsIdSecretRegenerate = <TError = ErrorType<ApiErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApplicationsIdSecretRegenerate>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postApplicationsIdSecretRegenerate>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getPostApplicationsIdSecretRegenerateMutationOptions(options), queryClient);
};

/**
 * This endpoint is used by the Identity UI for SSO flow.
It validates credentials and returns a one-time token exchange URL.
The client should navigate to the exchange URL to set the HttpOnly cookie.

Flow: Login API ‚Üí Get Exchange Token ‚Üí Browser navigates to Exchange URL ‚Üí Cookie set
 * @summary SSO Login - validates credentials and returns exchange URL
 */
export const getPostIdentityAuthSsoLoginUrl = () => {
  return `/identity/auth/sso-login`;
};

export const postIdentityAuthSsoLogin = async (
  ssoLoginRequest: SsoLoginRequest,
  options?: RequestInit
): Promise<SsoLoginResponseApiResponse> => {
  return customInstance<SsoLoginResponseApiResponse>(getPostIdentityAuthSsoLoginUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(ssoLoginRequest)
  });
};

export const getPostIdentityAuthSsoLoginMutationOptions = <
  TError = ErrorType<ApiErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postIdentityAuthSsoLogin>>,
    TError,
    { data: SsoLoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postIdentityAuthSsoLogin>>,
  TError,
  { data: SsoLoginRequest },
  TContext
> => {
  const mutationKey = ['postIdentityAuthSsoLogin'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postIdentityAuthSsoLogin>>,
    { data: SsoLoginRequest }
  > = props => {
    const { data } = props ?? {};

    return postIdentityAuthSsoLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAuthSsoLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postIdentityAuthSsoLogin>>>;
export type PostIdentityAuthSsoLoginMutationBody = SsoLoginRequest;
export type PostIdentityAuthSsoLoginMutationError = ErrorType<ApiErrorResponse>;

/**
 * @summary SSO Login - validates credentials and returns exchange URL
 */
export const usePostIdentityAuthSsoLogin = <TError = ErrorType<ApiErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postIdentityAuthSsoLogin>>,
      TError,
      { data: SsoLoginRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postIdentityAuthSsoLogin>>,
  TError,
  { data: SsoLoginRequest },
  TContext
> => {
  return useMutation(getPostIdentityAuthSsoLoginMutationOptions(options), queryClient);
};

/**
 * This endpoint is called via browser navigation (not CORS fetch) so the cookie
is set in first-party context and won't be blocked by third-party cookie restrictions.
 * @summary Exchange one-time auth token for session cookie - browser navigates here directly
 */
export const getGetIdentityAuthExchangeTokenUrl = (params?: GetIdentityAuthExchangeTokenParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/identity/auth/exchange-token?${stringifiedParams}`
    : `/identity/auth/exchange-token`;
};

export const getIdentityAuthExchangeToken = async (
  params?: GetIdentityAuthExchangeTokenParams,
  options?: RequestInit
): Promise<void> => {
  return customInstance<void>(getGetIdentityAuthExchangeTokenUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetIdentityAuthExchangeTokenQueryKey = (params?: GetIdentityAuthExchangeTokenParams) => {
  return [`/identity/auth/exchange-token`, ...(params ? [params] : [])] as const;
};

export const getGetIdentityAuthExchangeTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthExchangeTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIdentityAuthExchangeTokenQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>> = ({ signal }) =>
    getIdentityAuthExchangeToken(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetIdentityAuthExchangeTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>
>;
export type GetIdentityAuthExchangeTokenQueryError = ErrorType<unknown>;

export function useGetIdentityAuthExchangeToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
  TError = ErrorType<unknown>
>(
  params: undefined | GetIdentityAuthExchangeTokenParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthExchangeToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthExchangeTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthExchangeToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthExchangeTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Exchange one-time auth token for session cookie - browser navigates here directly
 */

export function useGetIdentityAuthExchangeToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthExchangeTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthExchangeToken>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIdentityAuthExchangeTokenQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get current session - verifies SSO cookie and returns user info
 */
export const getGetIdentityAuthSessionUrl = () => {
  return `/identity/auth/session`;
};

export const getIdentityAuthSession = async (options?: RequestInit): Promise<SsoSessionResponseApiResponse> => {
  return customInstance<SsoSessionResponseApiResponse>(getGetIdentityAuthSessionUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetIdentityAuthSessionQueryKey = () => {
  return [`/identity/auth/session`] as const;
};

export const getGetIdentityAuthSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getIdentityAuthSession>>,
  TError = ErrorType<ApiErrorResponse>
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthSession>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIdentityAuthSessionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIdentityAuthSession>>> = ({ signal }) =>
    getIdentityAuthSession({ signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIdentityAuthSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetIdentityAuthSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getIdentityAuthSession>>>;
export type GetIdentityAuthSessionQueryError = ErrorType<ApiErrorResponse>;

export function useGetIdentityAuthSession<
  TData = Awaited<ReturnType<typeof getIdentityAuthSession>>,
  TError = ErrorType<ApiErrorResponse>
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthSession>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthSession>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthSession<
  TData = Awaited<ReturnType<typeof getIdentityAuthSession>>,
  TError = ErrorType<ApiErrorResponse>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthSession>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthSession>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthSession<
  TData = Awaited<ReturnType<typeof getIdentityAuthSession>>,
  TError = ErrorType<ApiErrorResponse>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthSession>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get current session - verifies SSO cookie and returns user info
 */

export function useGetIdentityAuthSession<
  TData = Awaited<ReturnType<typeof getIdentityAuthSession>>,
  TError = ErrorType<ApiErrorResponse>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthSession>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIdentityAuthSessionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Flow:
1. App redirects browser to: gateway.test/identity/auth/check-sso?returnUrl=https://sso.test/...
2. This endpoint checks the AlfredSession cookie
3. If authenticated: generate one-time token and redirect back with token
4. If not authenticated: redirect back with error param
 * @summary Check SSO session and redirect back to app with auth data
Used for cross-domain SSO - browser redirects here, we check cookie, and redirect back with token
 */
export const getGetIdentityAuthCheckSsoUrl = (params?: GetIdentityAuthCheckSsoParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/identity/auth/check-sso?${stringifiedParams}` : `/identity/auth/check-sso`;
};

export const getIdentityAuthCheckSso = async (
  params?: GetIdentityAuthCheckSsoParams,
  options?: RequestInit
): Promise<void> => {
  return customInstance<void>(getGetIdentityAuthCheckSsoUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetIdentityAuthCheckSsoQueryKey = (params?: GetIdentityAuthCheckSsoParams) => {
  return [`/identity/auth/check-sso`, ...(params ? [params] : [])] as const;
};

export const getGetIdentityAuthCheckSsoQueryOptions = <
  TData = Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthCheckSsoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthCheckSso>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIdentityAuthCheckSsoQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIdentityAuthCheckSso>>> = ({ signal }) =>
    getIdentityAuthCheckSso(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetIdentityAuthCheckSsoQueryResult = NonNullable<Awaited<ReturnType<typeof getIdentityAuthCheckSso>>>;
export type GetIdentityAuthCheckSsoQueryError = ErrorType<unknown>;

export function useGetIdentityAuthCheckSso<
  TData = Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
  TError = ErrorType<unknown>
>(
  params: undefined | GetIdentityAuthCheckSsoParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthCheckSso>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthCheckSso>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthCheckSso<
  TData = Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthCheckSsoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthCheckSso>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthCheckSso>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthCheckSso<
  TData = Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthCheckSsoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthCheckSso>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Check SSO session and redirect back to app with auth data
Used for cross-domain SSO - browser redirects here, we check cookie, and redirect back with token
 */

export function useGetIdentityAuthCheckSso<
  TData = Awaited<ReturnType<typeof getIdentityAuthCheckSso>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityAuthCheckSsoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthCheckSso>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIdentityAuthCheckSsoQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Validate SSO token and return user data without consuming it
Used by frontend to get user data from sso_token before creating local session
 */
export const getGetIdentityAuthValidateTokenUrl = (params?: GetIdentityAuthValidateTokenParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/identity/auth/validate-token?${stringifiedParams}`
    : `/identity/auth/validate-token`;
};

export const getIdentityAuthValidateToken = async (
  params?: GetIdentityAuthValidateTokenParams,
  options?: RequestInit
): Promise<SessionUserInfoDtoApiResponse> => {
  return customInstance<SessionUserInfoDtoApiResponse>(getGetIdentityAuthValidateTokenUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetIdentityAuthValidateTokenQueryKey = (params?: GetIdentityAuthValidateTokenParams) => {
  return [`/identity/auth/validate-token`, ...(params ? [params] : [])] as const;
};

export const getGetIdentityAuthValidateTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
  TError = ErrorType<SessionUserInfoDtoApiResponse>
>(
  params?: GetIdentityAuthValidateTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthValidateToken>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIdentityAuthValidateTokenQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIdentityAuthValidateToken>>> = ({ signal }) =>
    getIdentityAuthValidateToken(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetIdentityAuthValidateTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIdentityAuthValidateToken>>
>;
export type GetIdentityAuthValidateTokenQueryError = ErrorType<SessionUserInfoDtoApiResponse>;

export function useGetIdentityAuthValidateToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
  TError = ErrorType<SessionUserInfoDtoApiResponse>
>(
  params: undefined | GetIdentityAuthValidateTokenParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthValidateToken>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthValidateToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthValidateToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
  TError = ErrorType<SessionUserInfoDtoApiResponse>
>(
  params?: GetIdentityAuthValidateTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthValidateToken>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
          TError,
          Awaited<ReturnType<typeof getIdentityAuthValidateToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityAuthValidateToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
  TError = ErrorType<SessionUserInfoDtoApiResponse>
>(
  params?: GetIdentityAuthValidateTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthValidateToken>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Validate SSO token and return user data without consuming it
Used by frontend to get user data from sso_token before creating local session
 */

export function useGetIdentityAuthValidateToken<
  TData = Awaited<ReturnType<typeof getIdentityAuthValidateToken>>,
  TError = ErrorType<SessionUserInfoDtoApiResponse>
>(
  params?: GetIdentityAuthValidateTokenParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityAuthValidateToken>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIdentityAuthValidateTokenQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary SSO Logout - clears the authentication cookie
 */
export const getPostIdentityAuthLogoutUrl = () => {
  return `/identity/auth/logout`;
};

export const postIdentityAuthLogout = async (options?: RequestInit): Promise<ObjectApiResponse> => {
  return customInstance<ObjectApiResponse>(getPostIdentityAuthLogoutUrl(), {
    ...options,
    method: 'POST'
  });
};

export const getPostIdentityAuthLogoutMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIdentityAuthLogout>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof postIdentityAuthLogout>>, TError, void, TContext> => {
  const mutationKey = ['postIdentityAuthLogout'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIdentityAuthLogout>>, void> = () => {
    return postIdentityAuthLogout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAuthLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof postIdentityAuthLogout>>>;

export type PostIdentityAuthLogoutMutationError = ErrorType<unknown>;

/**
 * @summary SSO Logout - clears the authentication cookie
 */
export const usePostIdentityAuthLogout = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIdentityAuthLogout>>, TError, void, TContext>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postIdentityAuthLogout>>, TError, void, TContext> => {
  return useMutation(getPostIdentityAuthLogoutMutationOptions(options), queryClient);
};

/**
 * @summary Initiate forgot password flow
 */
export const getPostIdentityAuthForgotPasswordUrl = () => {
  return `/identity/auth/forgot-password`;
};

export const postIdentityAuthForgotPassword = async (
  forgotPasswordRequest: ForgotPasswordRequest,
  options?: RequestInit
): Promise<ObjectApiResponse> => {
  return customInstance<ObjectApiResponse>(getPostIdentityAuthForgotPasswordUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(forgotPasswordRequest)
  });
};

export const getPostIdentityAuthForgotPasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postIdentityAuthForgotPassword>>,
    TError,
    { data: ForgotPasswordRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postIdentityAuthForgotPassword>>,
  TError,
  { data: ForgotPasswordRequest },
  TContext
> => {
  const mutationKey = ['postIdentityAuthForgotPassword'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postIdentityAuthForgotPassword>>,
    { data: ForgotPasswordRequest }
  > = props => {
    const { data } = props ?? {};

    return postIdentityAuthForgotPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAuthForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof postIdentityAuthForgotPassword>>
>;
export type PostIdentityAuthForgotPasswordMutationBody = ForgotPasswordRequest;
export type PostIdentityAuthForgotPasswordMutationError = ErrorType<unknown>;

/**
 * @summary Initiate forgot password flow
 */
export const usePostIdentityAuthForgotPassword = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postIdentityAuthForgotPassword>>,
      TError,
      { data: ForgotPasswordRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postIdentityAuthForgotPassword>>,
  TError,
  { data: ForgotPasswordRequest },
  TContext
> => {
  return useMutation(getPostIdentityAuthForgotPasswordMutationOptions(options), queryClient);
};

/**
 * @summary Reset password using token
 */
export const getPostIdentityAuthResetPasswordUrl = () => {
  return `/identity/auth/reset-password`;
};

export const postIdentityAuthResetPassword = async (
  resetPasswordRequest: ResetPasswordRequest,
  options?: RequestInit
): Promise<ObjectApiResponse> => {
  return customInstance<ObjectApiResponse>(getPostIdentityAuthResetPasswordUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(resetPasswordRequest)
  });
};

export const getPostIdentityAuthResetPasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postIdentityAuthResetPassword>>,
    TError,
    { data: ResetPasswordRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postIdentityAuthResetPassword>>,
  TError,
  { data: ResetPasswordRequest },
  TContext
> => {
  const mutationKey = ['postIdentityAuthResetPassword'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postIdentityAuthResetPassword>>,
    { data: ResetPasswordRequest }
  > = props => {
    const { data } = props ?? {};

    return postIdentityAuthResetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIdentityAuthResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof postIdentityAuthResetPassword>>
>;
export type PostIdentityAuthResetPasswordMutationBody = ResetPasswordRequest;
export type PostIdentityAuthResetPasswordMutationError = ErrorType<unknown>;

/**
 * @summary Reset password using token
 */
export const usePostIdentityAuthResetPassword = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postIdentityAuthResetPassword>>,
      TError,
      { data: ResetPasswordRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postIdentityAuthResetPassword>>,
  TError,
  { data: ResetPasswordRequest },
  TContext
> => {
  return useMutation(getPostIdentityAuthResetPasswordMutationOptions(options), queryClient);
};

/**
 * @summary OAuth2/OIDC Authorize Endpoint
 */
export const getGetConnectAuthorizeUrl = (params?: GetConnectAuthorizeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/connect/authorize?${stringifiedParams}` : `/connect/authorize`;
};

export const getConnectAuthorize = async (params?: GetConnectAuthorizeParams, options?: RequestInit): Promise<void> => {
  return customInstance<void>(getGetConnectAuthorizeUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetConnectAuthorizeQueryKey = (params?: GetConnectAuthorizeParams) => {
  return [`/connect/authorize`, ...(params ? [params] : [])] as const;
};

export const getGetConnectAuthorizeQueryOptions = <
  TData = Awaited<ReturnType<typeof getConnectAuthorize>>,
  TError = ErrorType<unknown>
>(
  params?: GetConnectAuthorizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectAuthorize>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConnectAuthorizeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConnectAuthorize>>> = ({ signal }) =>
    getConnectAuthorize(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConnectAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConnectAuthorizeQueryResult = NonNullable<Awaited<ReturnType<typeof getConnectAuthorize>>>;
export type GetConnectAuthorizeQueryError = ErrorType<unknown>;

export function useGetConnectAuthorize<
  TData = Awaited<ReturnType<typeof getConnectAuthorize>>,
  TError = ErrorType<unknown>
>(
  params: undefined | GetConnectAuthorizeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectAuthorize>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectAuthorize>>,
          TError,
          Awaited<ReturnType<typeof getConnectAuthorize>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConnectAuthorize<
  TData = Awaited<ReturnType<typeof getConnectAuthorize>>,
  TError = ErrorType<unknown>
>(
  params?: GetConnectAuthorizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectAuthorize>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectAuthorize>>,
          TError,
          Awaited<ReturnType<typeof getConnectAuthorize>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConnectAuthorize<
  TData = Awaited<ReturnType<typeof getConnectAuthorize>>,
  TError = ErrorType<unknown>
>(
  params?: GetConnectAuthorizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectAuthorize>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary OAuth2/OIDC Authorize Endpoint
 */

export function useGetConnectAuthorize<
  TData = Awaited<ReturnType<typeof getConnectAuthorize>>,
  TError = ErrorType<unknown>
>(
  params?: GetConnectAuthorizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectAuthorize>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConnectAuthorizeQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary OAuth2/OIDC Authorize Endpoint
 */
export const getPostConnectAuthorizeUrl = (params?: PostConnectAuthorizeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/connect/authorize?${stringifiedParams}` : `/connect/authorize`;
};

export const postConnectAuthorize = async (
  params?: PostConnectAuthorizeParams,
  options?: RequestInit
): Promise<void> => {
  return customInstance<void>(getPostConnectAuthorizeUrl(params), {
    ...options,
    method: 'POST'
  });
};

export const getPostConnectAuthorizeMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postConnectAuthorize>>,
    TError,
    { params?: PostConnectAuthorizeParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postConnectAuthorize>>,
  TError,
  { params?: PostConnectAuthorizeParams },
  TContext
> => {
  const mutationKey = ['postConnectAuthorize'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postConnectAuthorize>>,
    { params?: PostConnectAuthorizeParams }
  > = props => {
    const { params } = props ?? {};

    return postConnectAuthorize(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostConnectAuthorizeMutationResult = NonNullable<Awaited<ReturnType<typeof postConnectAuthorize>>>;

export type PostConnectAuthorizeMutationError = ErrorType<unknown>;

/**
 * @summary OAuth2/OIDC Authorize Endpoint
 */
export const usePostConnectAuthorize = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postConnectAuthorize>>,
      TError,
      { params?: PostConnectAuthorizeParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postConnectAuthorize>>,
  TError,
  { params?: PostConnectAuthorizeParams },
  TContext
> => {
  return useMutation(getPostConnectAuthorizeMutationOptions(options), queryClient);
};

/**
 * @summary OAuth2/OIDC Token Endpoint
 */
export const getPostConnectTokenUrl = () => {
  return `/connect/token`;
};

export const postConnectToken = async (
  postConnectTokenBody: PostConnectTokenBody,
  options?: RequestInit
): Promise<void> => {
  const formUrlEncoded = new URLSearchParams();

  if (postConnectTokenBody.grant_type !== undefined) {
    formUrlEncoded.append(`grant_type`, postConnectTokenBody.grant_type);
  }

  if (postConnectTokenBody.client_id !== undefined) {
    formUrlEncoded.append(`client_id`, postConnectTokenBody.client_id);
  }

  if (postConnectTokenBody.client_secret !== undefined) {
    formUrlEncoded.append(`client_secret`, postConnectTokenBody.client_secret);
  }

  if (postConnectTokenBody.code !== undefined) {
    formUrlEncoded.append(`code`, postConnectTokenBody.code);
  }

  if (postConnectTokenBody.redirect_uri !== undefined) {
    formUrlEncoded.append(`redirect_uri`, postConnectTokenBody.redirect_uri);
  }

  if (postConnectTokenBody.code_verifier !== undefined) {
    formUrlEncoded.append(`code_verifier`, postConnectTokenBody.code_verifier);
  }

  if (postConnectTokenBody.refresh_token !== undefined) {
    formUrlEncoded.append(`refresh_token`, postConnectTokenBody.refresh_token);
  }

  if (postConnectTokenBody.scope !== undefined) {
    formUrlEncoded.append(`scope`, postConnectTokenBody.scope);
  }

  return customInstance<void>(getPostConnectTokenUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: formUrlEncoded
  });
};

export const getPostConnectTokenMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postConnectToken>>,
    TError,
    { data: PostConnectTokenBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postConnectToken>>,
  TError,
  { data: PostConnectTokenBody },
  TContext
> => {
  const mutationKey = ['postConnectToken'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postConnectToken>>,
    { data: PostConnectTokenBody }
  > = props => {
    const { data } = props ?? {};

    return postConnectToken(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostConnectTokenMutationResult = NonNullable<Awaited<ReturnType<typeof postConnectToken>>>;
export type PostConnectTokenMutationBody = PostConnectTokenBody;
export type PostConnectTokenMutationError = ErrorType<unknown>;

/**
 * @summary OAuth2/OIDC Token Endpoint
 */
export const usePostConnectToken = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postConnectToken>>,
      TError,
      { data: PostConnectTokenBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postConnectToken>>,
  TError,
  { data: PostConnectTokenBody },
  TContext
> => {
  return useMutation(getPostConnectTokenMutationOptions(options), queryClient);
};

/**
 * Returns user information based on scopes granted:
- openid: sub (user ID)
- profile: name, username
- email: email, email_verified
 * @summary OIDC UserInfo Endpoint - returns user claims based on access token scopes
 */
export const getGetConnectUserinfoUrl = () => {
  return `/connect/userinfo`;
};

export const getConnectUserinfo = async (options?: RequestInit): Promise<void> => {
  return customInstance<void>(getGetConnectUserinfoUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetConnectUserinfoQueryKey = () => {
  return [`/connect/userinfo`] as const;
};

export const getGetConnectUserinfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getConnectUserinfo>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectUserinfo>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConnectUserinfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConnectUserinfo>>> = ({ signal }) =>
    getConnectUserinfo({ signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConnectUserinfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConnectUserinfoQueryResult = NonNullable<Awaited<ReturnType<typeof getConnectUserinfo>>>;
export type GetConnectUserinfoQueryError = ErrorType<unknown>;

export function useGetConnectUserinfo<
  TData = Awaited<ReturnType<typeof getConnectUserinfo>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectUserinfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectUserinfo>>,
          TError,
          Awaited<ReturnType<typeof getConnectUserinfo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConnectUserinfo<
  TData = Awaited<ReturnType<typeof getConnectUserinfo>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectUserinfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectUserinfo>>,
          TError,
          Awaited<ReturnType<typeof getConnectUserinfo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConnectUserinfo<
  TData = Awaited<ReturnType<typeof getConnectUserinfo>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectUserinfo>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary OIDC UserInfo Endpoint - returns user claims based on access token scopes
 */

export function useGetConnectUserinfo<
  TData = Awaited<ReturnType<typeof getConnectUserinfo>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectUserinfo>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConnectUserinfoQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary OIDC Logout / End Session Endpoint with validation
 */
export const getGetConnectLogoutUrl = (params?: GetConnectLogoutParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/connect/logout?${stringifiedParams}` : `/connect/logout`;
};

export const getConnectLogout = async (params?: GetConnectLogoutParams, options?: RequestInit): Promise<void> => {
  return customInstance<void>(getGetConnectLogoutUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetConnectLogoutQueryKey = (params?: GetConnectLogoutParams) => {
  return [`/connect/logout`, ...(params ? [params] : [])] as const;
};

export const getGetConnectLogoutQueryOptions = <
  TData = Awaited<ReturnType<typeof getConnectLogout>>,
  TError = ErrorType<unknown>
>(
  params?: GetConnectLogoutParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectLogout>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConnectLogoutQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConnectLogout>>> = ({ signal }) =>
    getConnectLogout(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConnectLogout>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConnectLogoutQueryResult = NonNullable<Awaited<ReturnType<typeof getConnectLogout>>>;
export type GetConnectLogoutQueryError = ErrorType<unknown>;

export function useGetConnectLogout<TData = Awaited<ReturnType<typeof getConnectLogout>>, TError = ErrorType<unknown>>(
  params: undefined | GetConnectLogoutParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectLogout>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectLogout>>,
          TError,
          Awaited<ReturnType<typeof getConnectLogout>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConnectLogout<TData = Awaited<ReturnType<typeof getConnectLogout>>, TError = ErrorType<unknown>>(
  params?: GetConnectLogoutParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectLogout>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectLogout>>,
          TError,
          Awaited<ReturnType<typeof getConnectLogout>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConnectLogout<TData = Awaited<ReturnType<typeof getConnectLogout>>, TError = ErrorType<unknown>>(
  params?: GetConnectLogoutParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectLogout>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary OIDC Logout / End Session Endpoint with validation
 */

export function useGetConnectLogout<TData = Awaited<ReturnType<typeof getConnectLogout>>, TError = ErrorType<unknown>>(
  params?: GetConnectLogoutParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConnectLogout>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConnectLogoutQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Initiates a challenge to an external provider (e.g., Google)
 */
export const getGetIdentityExternalAuthChallengeUrl = (params?: GetIdentityExternalAuthChallengeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/identity/external-auth/challenge?${stringifiedParams}`
    : `/identity/external-auth/challenge`;
};

export const getIdentityExternalAuthChallenge = async (
  params?: GetIdentityExternalAuthChallengeParams,
  options?: RequestInit
): Promise<void> => {
  return customInstance<void>(getGetIdentityExternalAuthChallengeUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetIdentityExternalAuthChallengeQueryKey = (params?: GetIdentityExternalAuthChallengeParams) => {
  return [`/identity/external-auth/challenge`, ...(params ? [params] : [])] as const;
};

export const getGetIdentityExternalAuthChallengeQueryOptions = <
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthChallengeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIdentityExternalAuthChallengeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>> = ({ signal }) =>
    getIdentityExternalAuthChallenge(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetIdentityExternalAuthChallengeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>
>;
export type GetIdentityExternalAuthChallengeQueryError = ErrorType<unknown>;

export function useGetIdentityExternalAuthChallenge<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
  TError = ErrorType<unknown>
>(
  params: undefined | GetIdentityExternalAuthChallengeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
          TError,
          Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityExternalAuthChallenge<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthChallengeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
          TError,
          Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityExternalAuthChallenge<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthChallengeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Initiates a challenge to an external provider (e.g., Google)
 */

export function useGetIdentityExternalAuthChallenge<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthChallengeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthChallenge>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIdentityExternalAuthChallengeQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Handle callback from external provider
 */
export const getGetIdentityExternalAuthCallbackUrl = (params?: GetIdentityExternalAuthCallbackParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/identity/external-auth/callback?${stringifiedParams}`
    : `/identity/external-auth/callback`;
};

export const getIdentityExternalAuthCallback = async (
  params?: GetIdentityExternalAuthCallbackParams,
  options?: RequestInit
): Promise<void> => {
  return customInstance<void>(getGetIdentityExternalAuthCallbackUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetIdentityExternalAuthCallbackQueryKey = (params?: GetIdentityExternalAuthCallbackParams) => {
  return [`/identity/external-auth/callback`, ...(params ? [params] : [])] as const;
};

export const getGetIdentityExternalAuthCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthCallbackParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIdentityExternalAuthCallbackQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>> = ({ signal }) =>
    getIdentityExternalAuthCallback(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetIdentityExternalAuthCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>
>;
export type GetIdentityExternalAuthCallbackQueryError = ErrorType<unknown>;

export function useGetIdentityExternalAuthCallback<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
  TError = ErrorType<unknown>
>(
  params: undefined | GetIdentityExternalAuthCallbackParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityExternalAuthCallback<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthCallbackParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIdentityExternalAuthCallback<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthCallbackParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Handle callback from external provider
 */

export function useGetIdentityExternalAuthCallback<
  TData = Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>,
  TError = ErrorType<unknown>
>(
  params?: GetIdentityExternalAuthCallbackParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIdentityExternalAuthCallback>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIdentityExternalAuthCallbackQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Returns 200 OK if the service is up and running.
Used by load balancers and monitoring tools.
 * @summary Health check endpoint
 */
export const getGetHealthUrl = () => {
  return `/health`;
};

export const getHealth = async (options?: RequestInit): Promise<void> => {
  return customInstance<void>(getGetHealthUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetHealthQueryKey = () => {
  return [`/health`] as const;
};

export const getGetHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHealthQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealth>>> = ({ signal }) =>
    getHealth({ signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getHealth>>>;
export type GetHealthQueryError = ErrorType<unknown>;

export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = ErrorType<unknown>>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getHealth>>, TError, Awaited<ReturnType<typeof getHealth>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Health check endpoint
 */

export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHealthQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Forces the generation of a new signing key and adds it to the key ring.
Old keys remain valid for verification until they expire.
Requires Admin or Owner role.
 * @summary Manually rotate authentication signing keys
 */
export const getPostApiV1KeysRotateUrl = () => {
  return `/api/v1/keys/rotate`;
};

export const postApiV1KeysRotate = async (options?: RequestInit): Promise<RotateSigningKeyResult> => {
  return customInstance<RotateSigningKeyResult>(getPostApiV1KeysRotateUrl(), {
    ...options,
    method: 'POST'
  });
};

export const getPostApiV1KeysRotateMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postApiV1KeysRotate>>, TError, void, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof postApiV1KeysRotate>>, TError, void, TContext> => {
  const mutationKey = ['postApiV1KeysRotate'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1KeysRotate>>, void> = () => {
    return postApiV1KeysRotate(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiV1KeysRotateMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1KeysRotate>>>;

export type PostApiV1KeysRotateMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Manually rotate authentication signing keys
 */
export const usePostApiV1KeysRotate = <TError = ErrorType<ProblemDetails>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postApiV1KeysRotate>>, TError, void, TContext>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postApiV1KeysRotate>>, TError, void, TContext> => {
  return useMutation(getPostApiV1KeysRotateMutationOptions(options), queryClient);
};

/**
 * Supports filtering, sorting, and pagination via query parameters.
 * @summary Get paginated list of permissions
 */
export const getGetPermissionsUrl = (params?: GetPermissionsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/permissions?${stringifiedParams}` : `/permissions`;
};

export const getPermissions = async (
  params?: GetPermissionsParams,
  options?: RequestInit
): Promise<PermissionDtoApiPagedResponse> => {
  return customInstance<PermissionDtoApiPagedResponse>(getGetPermissionsUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetPermissionsQueryKey = (params?: GetPermissionsParams) => {
  return [`/permissions`, ...(params ? [params] : [])] as const;
};

export const getGetPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPermissions>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetPermissionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissions>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPermissionsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPermissions>>> = ({ signal }) =>
    getPermissions(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPermissions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof getPermissions>>>;
export type GetPermissionsQueryError = ErrorType<ApiErrorResponse>;

export function useGetPermissions<
  TData = Awaited<ReturnType<typeof getPermissions>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params: undefined | GetPermissionsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissions>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissions>>,
          TError,
          Awaited<ReturnType<typeof getPermissions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPermissions<
  TData = Awaited<ReturnType<typeof getPermissions>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetPermissionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissions>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissions>>,
          TError,
          Awaited<ReturnType<typeof getPermissions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPermissions<
  TData = Awaited<ReturnType<typeof getPermissions>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetPermissionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissions>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get paginated list of permissions
 */

export function useGetPermissions<
  TData = Awaited<ReturnType<typeof getPermissions>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetPermissionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissions>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPermissionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Supports filtering, sorting, and pagination via query parameters.
 * @summary Get paginated list of roles
 */
export const getGetRolesUrl = (params?: GetRolesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/roles?${stringifiedParams}` : `/roles`;
};

export const getRoles = async (params?: GetRolesParams, options?: RequestInit): Promise<RoleDtoApiPagedResponse> => {
  return customInstance<RoleDtoApiPagedResponse>(getGetRolesUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetRolesQueryKey = (params?: GetRolesParams) => {
  return [`/roles`, ...(params ? [params] : [])] as const;
};

export const getGetRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoles>>,
  TError = ErrorType<ApiErrorResponse>
>(
  params?: GetRolesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRolesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoles>>> = ({ signal }) =>
    getRoles(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getRoles>>>;
export type GetRolesQueryError = ErrorType<ApiErrorResponse>;

export function useGetRoles<TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorType<ApiErrorResponse>>(
  params: undefined | GetRolesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRoles>>, TError, Awaited<ReturnType<typeof getRoles>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRoles<TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorType<ApiErrorResponse>>(
  params?: GetRolesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRoles>>, TError, Awaited<ReturnType<typeof getRoles>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRoles<TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorType<ApiErrorResponse>>(
  params?: GetRolesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get paginated list of roles
 */

export function useGetRoles<TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorType<ApiErrorResponse>>(
  params?: GetRolesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRolesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Create a new role
 */
export const getPostRolesUrl = () => {
  return `/roles`;
};

export const postRoles = async (
  createRoleCommand: CreateRoleCommand,
  options?: RequestInit
): Promise<RoleDtoApiResponse> => {
  return customInstance<RoleDtoApiResponse>(getPostRolesUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createRoleCommand)
  });
};

export const getPostRolesMutationOptions = <TError = ErrorType<RoleDtoApiResponse>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postRoles>>, TError, { data: CreateRoleCommand }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof postRoles>>, TError, { data: CreateRoleCommand }, TContext> => {
  const mutationKey = ['postRoles'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRoles>>, { data: CreateRoleCommand }> = props => {
    const { data } = props ?? {};

    return postRoles(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostRolesMutationResult = NonNullable<Awaited<ReturnType<typeof postRoles>>>;
export type PostRolesMutationBody = CreateRoleCommand;
export type PostRolesMutationError = ErrorType<RoleDtoApiResponse>;

/**
 * @summary Create a new role
 */
export const usePostRoles = <TError = ErrorType<RoleDtoApiResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postRoles>>, TError, { data: CreateRoleCommand }, TContext>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postRoles>>, TError, { data: CreateRoleCommand }, TContext> => {
  return useMutation(getPostRolesMutationOptions(options), queryClient);
};

/**
 * @summary Get role by ID
 */
export const getGetRolesIdUrl = (id: string) => {
  return `/roles/${id}`;
};

export const getRolesId = async (id: string, options?: RequestInit): Promise<RoleDtoApiResponse> => {
  return customInstance<RoleDtoApiResponse>(getGetRolesIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

export const getGetRolesIdQueryKey = (id: string) => {
  return [`/roles/${id}`] as const;
};

export const getGetRolesIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getRolesId>>,
  TError = ErrorType<ProblemDetails>
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRolesIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesId>>> = ({ signal }) =>
    getRolesId(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRolesId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRolesIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesId>>>;
export type GetRolesIdQueryError = ErrorType<ProblemDetails>;

export function useGetRolesId<TData = Awaited<ReturnType<typeof getRolesId>>, TError = ErrorType<ProblemDetails>>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesId>>,
          TError,
          Awaited<ReturnType<typeof getRolesId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRolesId<TData = Awaited<ReturnType<typeof getRolesId>>, TError = ErrorType<ProblemDetails>>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesId>>,
          TError,
          Awaited<ReturnType<typeof getRolesId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRolesId<TData = Awaited<ReturnType<typeof getRolesId>>, TError = ErrorType<ProblemDetails>>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get role by ID
 */

export function useGetRolesId<TData = Awaited<ReturnType<typeof getRolesId>>, TError = ErrorType<ProblemDetails>>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRolesIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Update an existing role
 */
export const getPutRolesIdUrl = (id: string) => {
  return `/roles/${id}`;
};

export const putRolesId = async (
  id: string,
  updateRoleCommand: UpdateRoleCommand,
  options?: RequestInit
): Promise<RoleDtoApiResponse> => {
  return customInstance<RoleDtoApiResponse>(getPutRolesIdUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateRoleCommand)
  });
};

export const getPutRolesIdMutationOptions = <
  TError = ErrorType<RoleDtoApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putRolesId>>,
    TError,
    { id: string; data: UpdateRoleCommand },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putRolesId>>,
  TError,
  { id: string; data: UpdateRoleCommand },
  TContext
> => {
  const mutationKey = ['putRolesId'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putRolesId>>,
    { id: string; data: UpdateRoleCommand }
  > = props => {
    const { id, data } = props ?? {};

    return putRolesId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutRolesIdMutationResult = NonNullable<Awaited<ReturnType<typeof putRolesId>>>;
export type PutRolesIdMutationBody = UpdateRoleCommand;
export type PutRolesIdMutationError = ErrorType<RoleDtoApiResponse | ProblemDetails>;

/**
 * @summary Update an existing role
 */
export const usePutRolesId = <TError = ErrorType<RoleDtoApiResponse | ProblemDetails>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putRolesId>>,
      TError,
      { id: string; data: UpdateRoleCommand },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof putRolesId>>,
  TError,
  { id: string; data: UpdateRoleCommand },
  TContext
> => {
  return useMutation(getPutRolesIdMutationOptions(options), queryClient);
};

/**
 * @summary Delete a role
 */
export const getDeleteRolesIdUrl = (id: string) => {
  return `/roles/${id}`;
};

export const deleteRolesId = async (id: string, options?: RequestInit): Promise<RoleDtoApiResponse> => {
  return customInstance<RoleDtoApiResponse>(getDeleteRolesIdUrl(id), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteRolesIdMutationOptions = <
  TError = ErrorType<RoleDtoApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteRolesId>>, TError, { id: string }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteRolesId>>, TError, { id: string }, TContext> => {
  const mutationKey = ['deleteRolesId'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRolesId>>, { id: string }> = props => {
    const { id } = props ?? {};

    return deleteRolesId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRolesIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRolesId>>>;

export type DeleteRolesIdMutationError = ErrorType<RoleDtoApiResponse | ProblemDetails>;

/**
 * @summary Delete a role
 */
export const useDeleteRolesId = <TError = ErrorType<RoleDtoApiResponse | ProblemDetails>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteRolesId>>, TError, { id: string }, TContext>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteRolesId>>, TError, { id: string }, TContext> => {
  return useMutation(getDeleteRolesIdMutationOptions(options), queryClient);
};

/**
 * @summary Assign permissions to a role
 */
export const getPostRolesIdPermissionsUrl = (id: string) => {
  return `/roles/${id}/permissions`;
};

export const postRolesIdPermissions = async (
  id: string,
  postRolesIdPermissionsBody: string[],
  options?: RequestInit
): Promise<AddPermissionsToRoleResultApiResponse> => {
  return customInstance<AddPermissionsToRoleResultApiResponse>(getPostRolesIdPermissionsUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postRolesIdPermissionsBody)
  });
};

export const getPostRolesIdPermissionsMutationOptions = <
  TError = ErrorType<AddPermissionsToRoleResultApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postRolesIdPermissions>>,
    TError,
    { id: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postRolesIdPermissions>>,
  TError,
  { id: string; data: string[] },
  TContext
> => {
  const mutationKey = ['postRolesIdPermissions'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postRolesIdPermissions>>,
    { id: string; data: string[] }
  > = props => {
    const { id, data } = props ?? {};

    return postRolesIdPermissions(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostRolesIdPermissionsMutationResult = NonNullable<Awaited<ReturnType<typeof postRolesIdPermissions>>>;
export type PostRolesIdPermissionsMutationBody = string[];
export type PostRolesIdPermissionsMutationError = ErrorType<AddPermissionsToRoleResultApiResponse | ProblemDetails>;

/**
 * @summary Assign permissions to a role
 */
export const usePostRolesIdPermissions = <
  TError = ErrorType<AddPermissionsToRoleResultApiResponse | ProblemDetails>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postRolesIdPermissions>>,
      TError,
      { id: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postRolesIdPermissions>>,
  TError,
  { id: string; data: string[] },
  TContext
> => {
  return useMutation(getPostRolesIdPermissionsMutationOptions(options), queryClient);
};

/**
 * @summary Remove permissions from a role
 */
export const getDeleteRolesIdPermissionsUrl = (id: string) => {
  return `/roles/${id}/permissions`;
};

export const deleteRolesIdPermissions = async (
  id: string,
  deleteRolesIdPermissionsBody: string[],
  options?: RequestInit
): Promise<RemovePermissionsFromRoleResultApiResponse> => {
  return customInstance<RemovePermissionsFromRoleResultApiResponse>(getDeleteRolesIdPermissionsUrl(id), {
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deleteRolesIdPermissionsBody)
  });
};

export const getDeleteRolesIdPermissionsMutationOptions = <
  TError = ErrorType<RemovePermissionsFromRoleResultApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRolesIdPermissions>>,
    TError,
    { id: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRolesIdPermissions>>,
  TError,
  { id: string; data: string[] },
  TContext
> => {
  const mutationKey = ['deleteRolesIdPermissions'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRolesIdPermissions>>,
    { id: string; data: string[] }
  > = props => {
    const { id, data } = props ?? {};

    return deleteRolesIdPermissions(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRolesIdPermissionsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRolesIdPermissions>>>;
export type DeleteRolesIdPermissionsMutationBody = string[];
export type DeleteRolesIdPermissionsMutationError = ErrorType<
  RemovePermissionsFromRoleResultApiResponse | ProblemDetails
>;

/**
 * @summary Remove permissions from a role
 */
export const useDeleteRolesIdPermissions = <
  TError = ErrorType<RemovePermissionsFromRoleResultApiResponse | ProblemDetails>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRolesIdPermissions>>,
      TError,
      { id: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRolesIdPermissions>>,
  TError,
  { id: string; data: string[] },
  TContext
> => {
  return useMutation(getDeleteRolesIdPermissionsMutationOptions(options), queryClient);
};

/**
 * Supports filtering, sorting, and pagination via query parameters.
 * @summary Get paginated list of users
 */
export const getGetUsersUrl = (params?: GetUsersParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users?${stringifiedParams}` : `/users`;
};

export const getUsers = async (params?: GetUsersParams, options?: RequestInit): Promise<UserDtoApiPagedResponse> => {
  return customInstance<UserDtoApiPagedResponse>(getGetUsersUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetUsersQueryKey = (params?: GetUsersParams) => {
  return [`/users`, ...(params ? [params] : [])] as const;
};

export const getGetUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<UserDtoApiPagedResponse>
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) =>
    getUsers(params, { signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>;
export type GetUsersQueryError = ErrorType<UserDtoApiPagedResponse>;

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorType<UserDtoApiPagedResponse>>(
  params: undefined | GetUsersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getUsers>>, TError, Awaited<ReturnType<typeof getUsers>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorType<UserDtoApiPagedResponse>>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getUsers>>, TError, Awaited<ReturnType<typeof getUsers>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorType<UserDtoApiPagedResponse>>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get paginated list of users
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorType<UserDtoApiPagedResponse>>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUsersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Assign roles to a user
 */
export const getPostUsersUserIdRolesUrl = (userId: string) => {
  return `/users/${userId}/roles`;
};

export const postUsersUserIdRoles = async (
  userId: string,
  postUsersUserIdRolesBody: string[],
  options?: RequestInit
): Promise<AssignRolesToUserResultApiResponse> => {
  return customInstance<AssignRolesToUserResultApiResponse>(getPostUsersUserIdRolesUrl(userId), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postUsersUserIdRolesBody)
  });
};

export const getPostUsersUserIdRolesMutationOptions = <
  TError = ErrorType<AssignRolesToUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUsersUserIdRoles>>,
    TError,
    { userId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUsersUserIdRoles>>,
  TError,
  { userId: string; data: string[] },
  TContext
> => {
  const mutationKey = ['postUsersUserIdRoles'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUsersUserIdRoles>>,
    { userId: string; data: string[] }
  > = props => {
    const { userId, data } = props ?? {};

    return postUsersUserIdRoles(userId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersUserIdRolesMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersUserIdRoles>>>;
export type PostUsersUserIdRolesMutationBody = string[];
export type PostUsersUserIdRolesMutationError = ErrorType<AssignRolesToUserResultApiResponse | ProblemDetails>;

/**
 * @summary Assign roles to a user
 */
export const usePostUsersUserIdRoles = <
  TError = ErrorType<AssignRolesToUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postUsersUserIdRoles>>,
      TError,
      { userId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postUsersUserIdRoles>>,
  TError,
  { userId: string; data: string[] },
  TContext
> => {
  return useMutation(getPostUsersUserIdRolesMutationOptions(options), queryClient);
};

/**
 * @summary Revoke roles from a user
 */
export const getDeleteUsersUserIdRolesUrl = (userId: string) => {
  return `/users/${userId}/roles`;
};

export const deleteUsersUserIdRoles = async (
  userId: string,
  deleteUsersUserIdRolesBody: string[],
  options?: RequestInit
): Promise<RevokeRolesFromUserResultApiResponse> => {
  return customInstance<RevokeRolesFromUserResultApiResponse>(getDeleteUsersUserIdRolesUrl(userId), {
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deleteUsersUserIdRolesBody)
  });
};

export const getDeleteUsersUserIdRolesMutationOptions = <
  TError = ErrorType<RevokeRolesFromUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUsersUserIdRoles>>,
    TError,
    { userId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUsersUserIdRoles>>,
  TError,
  { userId: string; data: string[] },
  TContext
> => {
  const mutationKey = ['deleteUsersUserIdRoles'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUsersUserIdRoles>>,
    { userId: string; data: string[] }
  > = props => {
    const { userId, data } = props ?? {};

    return deleteUsersUserIdRoles(userId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUsersUserIdRolesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsersUserIdRoles>>>;
export type DeleteUsersUserIdRolesMutationBody = string[];
export type DeleteUsersUserIdRolesMutationError = ErrorType<RevokeRolesFromUserResultApiResponse | ProblemDetails>;

/**
 * @summary Revoke roles from a user
 */
export const useDeleteUsersUserIdRoles = <
  TError = ErrorType<RevokeRolesFromUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUsersUserIdRoles>>,
      TError,
      { userId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUsersUserIdRoles>>,
  TError,
  { userId: string; data: string[] },
  TContext
> => {
  return useMutation(getDeleteUsersUserIdRolesMutationOptions(options), queryClient);
};

/**
 * @summary Ban a user
 */
export const getPostUsersUserIdBanUrl = (userId: string) => {
  return `/users/${userId}/ban`;
};

export const postUsersUserIdBan = async (
  userId: string,
  banUserRequest: BanUserRequest,
  options?: RequestInit
): Promise<BanUserResultApiResponse> => {
  return customInstance<BanUserResultApiResponse>(getPostUsersUserIdBanUrl(userId), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(banUserRequest)
  });
};

export const getPostUsersUserIdBanMutationOptions = <
  TError = ErrorType<BanUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUsersUserIdBan>>,
    TError,
    { userId: string; data: BanUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUsersUserIdBan>>,
  TError,
  { userId: string; data: BanUserRequest },
  TContext
> => {
  const mutationKey = ['postUsersUserIdBan'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUsersUserIdBan>>,
    { userId: string; data: BanUserRequest }
  > = props => {
    const { userId, data } = props ?? {};

    return postUsersUserIdBan(userId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersUserIdBanMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersUserIdBan>>>;
export type PostUsersUserIdBanMutationBody = BanUserRequest;
export type PostUsersUserIdBanMutationError = ErrorType<BanUserResultApiResponse | ProblemDetails>;

/**
 * @summary Ban a user
 */
export const usePostUsersUserIdBan = <
  TError = ErrorType<BanUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postUsersUserIdBan>>,
      TError,
      { userId: string; data: BanUserRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postUsersUserIdBan>>,
  TError,
  { userId: string; data: BanUserRequest },
  TContext
> => {
  return useMutation(getPostUsersUserIdBanMutationOptions(options), queryClient);
};

/**
 * @summary Unban a user
 */
export const getPostUsersUserIdUnbanUrl = (userId: string) => {
  return `/users/${userId}/unban`;
};

export const postUsersUserIdUnban = async (
  userId: string,
  options?: RequestInit
): Promise<UnbanUserResultApiResponse> => {
  return customInstance<UnbanUserResultApiResponse>(getPostUsersUserIdUnbanUrl(userId), {
    ...options,
    method: 'POST'
  });
};

export const getPostUsersUserIdUnbanMutationOptions = <
  TError = ErrorType<UnbanUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersUserIdUnban>>, TError, { userId: string }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof postUsersUserIdUnban>>, TError, { userId: string }, TContext> => {
  const mutationKey = ['postUsersUserIdUnban'];

  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersUserIdUnban>>, { userId: string }> = props => {
    const { userId } = props ?? {};

    return postUsersUserIdUnban(userId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersUserIdUnbanMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersUserIdUnban>>>;

export type PostUsersUserIdUnbanMutationError = ErrorType<UnbanUserResultApiResponse | ProblemDetails>;

/**
 * @summary Unban a user
 */
export const usePostUsersUserIdUnban = <
  TError = ErrorType<UnbanUserResultApiResponse | ProblemDetails>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postUsersUserIdUnban>>,
      TError,
      { userId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postUsersUserIdUnban>>, TError, { userId: string }, TContext> => {
  return useMutation(getPostUsersUserIdUnbanMutationOptions(options), queryClient);
};

/**
 * @summary Get user ban history
 */
export const getGetUsersUserIdBanHistoryUrl = (userId: string) => {
  return `/users/${userId}/ban-history`;
};

export const getUsersUserIdBanHistory = async (
  userId: string,
  options?: RequestInit
): Promise<BanDtoListApiResponse> => {
  return customInstance<BanDtoListApiResponse>(getGetUsersUserIdBanHistoryUrl(userId), {
    ...options,
    method: 'GET'
  });
};

export const getGetUsersUserIdBanHistoryQueryKey = (userId: string) => {
  return [`/users/${userId}/ban-history`] as const;
};

export const getGetUsersUserIdBanHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdBanHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersUserIdBanHistoryQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUserIdBanHistory>>> = ({ signal }) =>
    getUsersUserIdBanHistory(userId, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!userId, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersUserIdBanHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersUserIdBanHistory>>>;
export type GetUsersUserIdBanHistoryQueryError = ErrorType<unknown>;

export function useGetUsersUserIdBanHistory<
  TData = Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdBanHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
          TError,
          Awaited<ReturnType<typeof getUsersUserIdBanHistory>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsersUserIdBanHistory<
  TData = Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdBanHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
          TError,
          Awaited<ReturnType<typeof getUsersUserIdBanHistory>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsersUserIdBanHistory<
  TData = Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdBanHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get user ban history
 */

export function useGetUsersUserIdBanHistory<
  TData = Awaited<ReturnType<typeof getUsersUserIdBanHistory>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdBanHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUsersUserIdBanHistoryQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get user activity logs
 */
export const getGetUsersUserIdActivitiesUrl = (userId: string, params?: GetUsersUserIdActivitiesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/users/${userId}/activities?${stringifiedParams}`
    : `/users/${userId}/activities`;
};

export const getUsersUserIdActivities = async (
  userId: string,
  params?: GetUsersUserIdActivitiesParams,
  options?: RequestInit
): Promise<ActivityLogDtoApiPagedResponse> => {
  return customInstance<ActivityLogDtoApiPagedResponse>(getGetUsersUserIdActivitiesUrl(userId, params), {
    ...options,
    method: 'GET'
  });
};

export const getGetUsersUserIdActivitiesQueryKey = (userId: string, params?: GetUsersUserIdActivitiesParams) => {
  return [`/users/${userId}/activities`, ...(params ? [params] : [])] as const;
};

export const getGetUsersUserIdActivitiesQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsersUserIdActivities>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  params?: GetUsersUserIdActivitiesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdActivities>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersUserIdActivitiesQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUserIdActivities>>> = ({ signal }) =>
    getUsersUserIdActivities(userId, params, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!userId, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsersUserIdActivities>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersUserIdActivitiesQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersUserIdActivities>>>;
export type GetUsersUserIdActivitiesQueryError = ErrorType<unknown>;

export function useGetUsersUserIdActivities<
  TData = Awaited<ReturnType<typeof getUsersUserIdActivities>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  params: undefined | GetUsersUserIdActivitiesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdActivities>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUserIdActivities>>,
          TError,
          Awaited<ReturnType<typeof getUsersUserIdActivities>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsersUserIdActivities<
  TData = Awaited<ReturnType<typeof getUsersUserIdActivities>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  params?: GetUsersUserIdActivitiesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdActivities>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUserIdActivities>>,
          TError,
          Awaited<ReturnType<typeof getUsersUserIdActivities>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsersUserIdActivities<
  TData = Awaited<ReturnType<typeof getUsersUserIdActivities>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  params?: GetUsersUserIdActivitiesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdActivities>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get user activity logs
 */

export function useGetUsersUserIdActivities<
  TData = Awaited<ReturnType<typeof getUsersUserIdActivities>>,
  TError = ErrorType<unknown>
>(
  userId: string,
  params?: GetUsersUserIdActivitiesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUserIdActivities>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUsersUserIdActivitiesQueryOptions(userId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Returns the public keys used to verify JWT tokens signed by this identity provider.
 * @summary Get JSON Web Key Set (JWKS)
 */
export const getGetWellKnownJwksJsonUrl = () => {
  return `/.well-known/jwks.json`;
};

export const getWellKnownJwksJson = async (options?: RequestInit): Promise<void> => {
  return customInstance<void>(getGetWellKnownJwksJsonUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetWellKnownJwksJsonQueryKey = () => {
  return [`/.well-known/jwks.json`] as const;
};

export const getGetWellKnownJwksJsonQueryOptions = <
  TData = Awaited<ReturnType<typeof getWellKnownJwksJson>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownJwksJson>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWellKnownJwksJsonQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWellKnownJwksJson>>> = ({ signal }) =>
    getWellKnownJwksJson({ signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWellKnownJwksJson>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWellKnownJwksJsonQueryResult = NonNullable<Awaited<ReturnType<typeof getWellKnownJwksJson>>>;
export type GetWellKnownJwksJsonQueryError = ErrorType<unknown>;

export function useGetWellKnownJwksJson<
  TData = Awaited<ReturnType<typeof getWellKnownJwksJson>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownJwksJson>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWellKnownJwksJson>>,
          TError,
          Awaited<ReturnType<typeof getWellKnownJwksJson>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWellKnownJwksJson<
  TData = Awaited<ReturnType<typeof getWellKnownJwksJson>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownJwksJson>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWellKnownJwksJson>>,
          TError,
          Awaited<ReturnType<typeof getWellKnownJwksJson>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWellKnownJwksJson<
  TData = Awaited<ReturnType<typeof getWellKnownJwksJson>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownJwksJson>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get JSON Web Key Set (JWKS)
 */

export function useGetWellKnownJwksJson<
  TData = Awaited<ReturnType<typeof getWellKnownJwksJson>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownJwksJson>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWellKnownJwksJsonQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Returns the OIDC discovery document containing standard endpoints and supported capabilities.
 * @summary Get OpenID Connect Configuration
 */
export const getGetWellKnownOpenidConfigurationUrl = () => {
  return `/.well-known/openid-configuration`;
};

export const getWellKnownOpenidConfiguration = async (options?: RequestInit): Promise<void> => {
  return customInstance<void>(getGetWellKnownOpenidConfigurationUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetWellKnownOpenidConfigurationQueryKey = () => {
  return [`/.well-known/openid-configuration`] as const;
};

export const getGetWellKnownOpenidConfigurationQueryOptions = <
  TData = Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWellKnownOpenidConfigurationQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>> = ({ signal }) =>
    getWellKnownOpenidConfiguration({ signal, ...requestOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWellKnownOpenidConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>
>;
export type GetWellKnownOpenidConfigurationQueryError = ErrorType<unknown>;

export function useGetWellKnownOpenidConfiguration<
  TData = Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
          TError,
          Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWellKnownOpenidConfiguration<
  TData = Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
          TError,
          Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWellKnownOpenidConfiguration<
  TData = Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

/**
 * @summary Get OpenID Connect Configuration
 */

export function useGetWellKnownOpenidConfiguration<
  TData = Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWellKnownOpenidConfiguration>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWellKnownOpenidConfigurationQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}
